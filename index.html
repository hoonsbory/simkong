<!DOCTYPE html>
<html>

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161543285-2"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-161543285-2');
    </script>

    <link rel="stylesheet" href="pcEtc/style.css">
    <link rel="icon" href="images/favicon.ico" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=0" />
    <meta property="og:image" content="https://mycolor.kr/pcImages/metaImg.jpg" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="나의 퍼스널 컬러는 무엇일까?" />
    <meta property="og:description"
        content="나는 웜톤일까? 쿨톤일까? 퍼스널컬러 진단하러가기!! 인공지능이 피부사진을 분석하여 결과를 알려줍니다. 회원가입없이 봄 웜톤, 여름 쿨톤, 가을 웜톤, 겨울 쿨톤 중 어디에 해당하는지 알아보세요." />
    <meta property="og:site_name" content="마이퍼스널컬러" />
    <link rel="canonical" href="https://mycolor.kr">
    <meta name="description"
        content="나는 웜톤일까? 쿨톤일까? 퍼스널컬러 진단하러가기!! 인공지능이 피부사진을 분석하여 결과를 알려줍니다. 회원가입없이 봄 웜톤, 여름 쿨톤, 가을 웜톤, 겨울 쿨톤 중 어디에 해당하는지 알아보세요.">
    <meta name="naver-site-verification" content="5dc3a557afdd3f611a7539f850a0d9a895ac7867" />
    <meta name="google-site-verification" content="x5-5ISQuDn24eQWdy-pG-KeCAYIi5iss2oL4dseBkS8" />
    <script data-ad-client="ca-pub-9106671749645972" async
        src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

    <title>마이퍼스널컬러</title>
</head>

<body>
    <img id="loading" src="pcImages/loading.gif"
        style="width : 65px; z-index : 999;display : none; position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%);">
    <canvas id="myCanvas" style="display: none;">
    </canvas>
    <canvas id="copyCanvas" style="display: none;">
    </canvas>
    <p id="resultText"></p>
    <p id="resultText"></p>
    <script src="pcEtc/color-thief.umd.js"></script>
    <script class="jsbin" src="https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
    <script src="pcEtc/Jcrop.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fontfaceobserver/2.1.0/fontfaceobserver.js"></script>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <div id="popup" style="display: none;">
        <div class="popupBg"></div>
        <div class="popDivFB" style=" background-color: rgba(230, 230, 230, 1);">
            <div>
                <img src="pcImages/warning.png">
                <p>현 브라우저는 호환되지 않을 수 있습니다.</p>
                <p>아래의 경로로 재접속해주세요</p>
                <p>* 우측하단 혹은 우측상단 터치 후</p>
                <p style="margin-bottom : 15px">* 열기 or Safari에서 열기</p>
            </div>
            <div class="confirmBtn"><span class="popupConfirm" onclick="popupConfirm('popup')">확 인</span></div>
        </div>
    </div>
    <div id="checkResult" style="display: none;">
        <div class="popupBg"></div>
        <div class="popDiv">
            <!-- <ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-1h7fvl13rbh9w" data-ad-width="250"
                data-ad-height="250"></ins> -->
            <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
            <!-- 메인페이지 팝업 -->
            <ins class="adsbygoogle" style="display:inline-block;width:250px;height:250px"
                data-ad-client="ca-pub-9106671749645972" data-ad-slot="1187857035"></ins>
            <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
            </script>
            <div id="checkFail">
                <p>피부색과 너무 거리가 멀어요!</p>
                <p style="margin-bottom : 15px">다른 부위로 시도해 주세요</p>
            </div>
            <div id="checkSuccess" style="display: none;">
                <p>피부 측정이 완료되었습니다!</p>
                <p style="margin-bottom : 15px">더 정확한 진단을 위해 다음 단계로 넘어갑니다</p>
            </div>
            <div class="confirmBtn"><span class="popupConfirm" onclick="popupConfirm('checkResult')">확 인</span></div>
        </div>
    </div>



    <div id="mainbody">
        <div id="mainTitle">
            <p>나는 <span id="warmSpan">웜톤</span>일까? <span id="coolSpan">쿨톤</span>일까?</p>
            <span id="bgSpan">퍼스널컬러</span><span id="noBgSpan"> 진단</span>
        </div>
        <div id="subTitle">'톤.잘.알'이 되어 훈남 , 훈녀 되자!</div>
        <div id="stepInfo">
            <div id="stepDiv"></div><span id="stepNum">1</span><span id="subInfo" style="vertical-align: top;">피부 사진
                촬영</span>
        </div>
        <div id="cropNotice">※ 손목 안쪽 피부가 꽉 차게 편집해주세요</div>
        <div class="file-upload">

            <input class="file-upload-input" id="fileInput" type='file' onclick="removeValue()"
                onchange="readURL(this);" accept="image/*" ; style="display: none; z-index: 998;" />
            <div class="image-upload-wrap" onclick="cameraCheck()">
                <div class="drag-text">
                    <img src="pcImages/camera.png" />
                    <h1>내 피부 촬영하기 </h1>
                </div>
            </div>
            <div id="slider" style="display: none;">

                <ul>
                    <li>
                        <div class="file-upload-content" id="noCamDiv" style="display: none;">
                            <img class="file-upload-image" id="realImage" src="#" alt="your image" />
                            <div style="margin-top : 2vh;">
                                <div class="btnGroup" id="editBtn" onclick="editImg()"><img
                                        src="pcImages/crop.png"><span>자르기</span></div>
                                <div class="btnGroup" id="rotateBtn" onclick="rotateImg('right')"><img
                                        src="pcImages/rotate.png"><span>회전</span></div>
                                <div class="btnGroup" id="refreshBtn" onclick="refresh()"><span
                                        style="padding-left: 0px">재설정</span></div>
                                <div class="btnGroup" onclick="crop()"><span style="padding-left: 0px">완료</span></div>
                            </div>
                            <div onclick="$('.file-upload-input').trigger( 'click' )" class="btnGroup" id="newfile">
                                <span>새로운 사진으로
                                    재시도</span></div>
                            <div class="arrowBtn" onclick="next()">다음 단계로</div>
                            <img id="originalImg" style="display: none;" />
                        </div>
                        <div id="mainCam" style="display: none;">
                            <video id="video" style="margin-bottom : 5vh; width: 100%; height : 60vh" autoplay
                                playsinline></video>
                            <div class="arrowBtn" onclick="camCheck()">피부톤 측정</div>
                            <canvas id="canvas" style="display: none;"></canvas>
                        </div>
                        <div id="failColor" style="display : none; height: 25px; width: 25px; border-radius: 15px;">
                        </div><span style="display: none;">사진의 상당부분이 피부색이 아닙니다. 다시 업로드하세요 </span>
                    </li>
                    <li>
                        <div class="question">
                            <p>1.나는 손목에 ○ ○색을 띄는 혈관이 많다</p>
                        </div>
                        <div class="choose" style="color: rgb(10, 59, 112);">
                            <div class="leftChoose" style="background-color: rgb(162,206,164);"
                                onclick="moveRight('warm')"><span>초록색</span></div>
                            <div class="middleBar"></div>
                            <div class="rightChoose" style="background-color: rgb(153,198,228);"
                                onclick="moveRight('cool')"><span>파란색</span></div>
                        </div>
                        <div id="askFooter">
                            <div class="leftArrow" onclick="moveLeft()">이전 단계로</div>
                        </div>
                    </li>
                    <li>
                        <div class="question">
                            <p>2.나는 헤어컬러가 ○ ○에 가깝다</p>
                        </div>
                        <div class="choose" style="color: white;">
                            <div class="leftChoose" style="background-color: rgb(117,76,36);"
                                onclick="moveRight('warm')"><span>브라운</span></div>
                            <div class="middleBar"></div>
                            <div class="rightChoose" style="background-color: black;" onclick="moveRight('cool')">
                                <span>블랙</span></div>
                        </div>
                        <div id="askFooter">
                            <div class="leftArrow" onclick="moveLeft()">이전 단계로</div>
                        </div>
                    </li>
                    <li>
                        <div class="question">
                            <p>3.나는 피부에 ○ ○ ○가 많다</p>
                        </div>
                        <div class="choose" style="color: rgb(10, 59, 112);">
                            <div class="leftChoose" style="background-color: rgb(253,215,153);"
                                onclick="moveRight('warm')"><span>노란기</span></div>
                            <div class="middleBar"></div>
                            <div class="rightChoose" style="background-color: rgb(250,208,184);"
                                onclick="moveRight('cool')"><span>붉은기</span></div>
                        </div>
                        <div id="askFooter">
                            <div class="leftArrow" onclick="moveLeft()">이전 단계로</div>
                        </div>
                    </li>
                    <li>
                        <div class="question">
                            <p>4.나는 햇볕에 장시간 있으면</p>
                        </div>
                        <div class="choose" style="color: white;">
                            <div class="leftChoose" style="background-color: rgb(167,135,84);"
                                onclick="moveRight('warm')"><span>쉽게 탄다</span></div>
                            <div class="middleBar"></div>
                            <div class="rightChoose" style="background-color: rgb(225,152,142);"
                                onclick="moveRight('cool')"><span>빨갛게 익는다</span></div>
                        </div>
                        <div id="askFooter">
                            <div class="leftArrow" onclick="moveLeft()">이전 단계로</div>
                        </div>
                    </li>
                    <li>
                        <div class="question">
                            <p>5.나는 ○ ○색 티셔츠가 더 잘어울린다</p>
                        </div>
                        <div class="choose" style="color: rgb(10, 59, 112);">
                            <div class="leftChoose"
                                style="border-top: 4px solid rgb(253,245,226); border-bottom: 4px solid rgb(253,245,226); background-color: rgb(253,245,226);"
                                onclick="moveRight('warm')"><span>아이보리 / 베이지</span></div>
                            <div class="middleBar"></div>
                            <div class="rightChoose"
                                style="border-top: 4px solid rgb(253,245,226); border-bottom: 4px solid rgb(253,245,226); background-color: white;"
                                onclick="moveRight('cool')"><span>순백색</span></div>
                        </div>
                        <div id="askFooter">
                            <div class="leftArrow" onclick="moveLeft()">이전 단계로</div>
                        </div>
                    </li>
                </ul>
            </div>


        </div>
        <div id="notice" style="text-align: center;">※ 피부톤은 <span
                style="background-color: rgb(10, 59, 112); color: white; padding : 4px; padding-bottom: 0px;">1단계
                카메라 측색값</span>과<p>
                <span style="background-color: rgb(10, 59, 112); color: white; padding : 4px; padding-bottom: 0px;">2단계
                    질문결과</span>를 종합하여 평가합니다</p>
        </div>
    </div>

    <script type="text/javascript" src="//t1.daumcdn.net/kas/static/ba.min.js" async></script>
    <div id="middleSec">

        <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9106671749645972"
            data-ad-slot="7150630154" data-ad-format="horizontal" data-full-width-responsive="true"></ins>
        <script>
            (adsbygoogle = window.adsbygoogle || []).push({});
        </script>
        <ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-t4tgk6re3upi" data-ad-width="320"
            data-ad-height="50"></ins>
        <div id="disqus_thread"></div>
        <ins class="kakao_ad_area" style="display:none;" data-ad-unit="DAN-t89ovgrl5so5" data-ad-width="320"
            data-ad-height="100"></ins>
    </div>
    <div id="footer">
        <div id="footerLeft">
            <img src="pcImages/footerImg.png">
            <p>mycolor.kr</p>
        </div>
        <div>제작 도움 - <a href="https://www.youtube.com/channel/UCQNE2JmbasNYbjGAcuBiRRg"
                style="color : rgb(10, 59, 112)">JoCoding Youtube</a></div>
        <div id="footerCenter"><a href="https://mycolor.kr/privacy" style="color : rgb(10, 59, 112)">개인정보 처리방침</a></div>
        <div id="footerRight">Contact : tonymkcv93@gmail.com</div>
    </div>
    <script type="text/javascript">
        //뒤로가기고 페이지에 진입하면 새로고침되게
        //엣지는 뒤로가기해도 캐시가없이 스크립트가 실행되었고, 크롬 일부버전은 persisted값이 false로만 나오는 버그가 있다고 한다. 그래서 window.performance조건을 추가해줌
        if (document.addEventListener) {
            window.addEventListener('pageshow', function (event) {
                if (event.persisted || window.performance &&
                    window.performance.navigation.type == 2) {
                    location.reload();
                }
            },
                false);
        }

        let appleCheck = false;
        let ua = navigator.userAgent || navigator.vendor || window.opera;
        if ((navigator.appName == 'Netscape' && navigator.userAgent.search('Trident') != -1) || (navigator.userAgent.indexOf("msie") != -1)) { // IE 일 경우
            document.documentElement.classList.add('fonts-loaded');
            alert("지원하지않는 브라우저입니다. 크롬,엣지,사파리 등의 브라우저를 이용해주세요");
        }
        let osInfo;
        let realOs;
        let floatOs = 0;
        if ((ua.indexOf("iPhone") > -1) || (ua.indexOf("iPad") > -1) || (ua.indexOf("iPod") > -1) || (ua.indexOf("Mac") > -1)) {
            appleCheck = true;
            osInfo = ua.split("OS")[1]
            realOs = osInfo.substring(1, 3) + "." + osInfo.substring(4, 5);

            //ios버전 추출해서 실수형으로.
            floatOs = parseFloat(realOs)
        }
        function isFacebookApp() {
            return ((ua.indexOf("FBAN") > -1) || (ua.indexOf("Instagram") > -1) || (ua.indexOf("FBAV") > -1) || (ua.indexOf("FBSV") > -1) || (ua.indexOf("FBSS") > -1) || (ua.indexOf("FBCR") > -1) || (ua.indexOf("FBID") > -1) || (ua.indexOf("FBCL") > -1) || (ua.indexOf("FBMD") > -1) || (ua.indexOf("FBDV") > -1) || (ua.indexOf("FBSN") > -1));
        };
        //페이스북에서 파일 업로드가 안된다. accept속성을 지우면 된다는 얘기가 많은데 시도해봐도 되지를 않아서 외부 브라우저를 키도록 유도함.
        if (isFacebookApp()) {
            document.getElementById("popup").style.display = "block";
        }

        if (ua.indexOf("Mobile") > -1) {
            document.getElementById("subInfo").style.position = "relative"
            document.getElementById("subInfo").style.top = "1vh"
        }


        var video = document.getElementById('video');

        //비디오 에러 캐치
        function camErr() {
            document.getElementById("noCamDiv").style.display = "block"
            // document.getElementById("fileInput").style.display = "block"
            // document.getElementById("camDiv").remove();
            document.getElementById("fileInput").click();
        }

        function popupConfirm(div) {
            if (document.getElementById("checkSuccess").style.display == "block") {
                moveRight("");
                uploadCheck = true;
                firstResult = [];
            }
            document.getElementById(div).style.display = "none";
        }

        document.getElementById("mainbody").scrollIntoView();


        //캠화면 캡쳐 및 주요컬러 도출
        function camCheck() {
            var camCanvas = document.getElementById('canvas');
            camCanvas.width = video.clientWidth;
            camCanvas.height = video.clientHeight;
            var context = camCanvas.getContext('2d');
            context.drawImage(video, 0, 0, video.clientWidth, video.clientHeight);
            color(camCanvas)
        }

        //폰트가 로드되기전까지 투명도를 줘서 안보이게 했다가 3초이내에 로딩되면 보이게함.
        //3초가 지나면 기본폰트로
        setTimeout(function () {
            document.body.style.opacity = 1
        }, 3000)
        var font = new FontFaceObserver('HSThin');
        font.load(null, 3000).then(function () {
            document.documentElement.classList.add('fonts-loaded');
        });

        //페이스북 인앱 브라우저에서 accept속성때문에 업로드가 안되는 버그가 있어서 대응

        //크롭없이 회전후 크롭할 경우  크롭을 하는 것은, 원본이미지를 캔버스에 옮겨오는 것으로 시작하는데, 크롭버튼을 누르지않고 회전부터 할 경우, 나중에 크롭할때 회전도가 달라 문제가 생긴다.
        //그래서 크롭을 시작하기전에 회전을 할 경우에만 한해서 캔버스에 그리고 시작한다. 사진을 올리자마자 캔버스에 그리는 게 편하지만, 편집을 원하지 않는 경우엔 불필요한 로딩을 하는 것이라 
        //따로 크롭 버튼을 넣은 것이다.
        var rotateCrop = false;
        //크롭버튼 클릭 유무. 크롭을 한적이 없다면 회전시 자동크롭
        var editCheck = false;

        //자르기버튼 비활성화를 위한 체크.
        var cropCheck = true;

        //첫 크롭여부 확인 후 처음인 경우만 드래그 안내
        var firstCrop = true;

        var uploadCheck = false;
        //업로드여부 체크해
        var slideCheck = 0;
        //슬라이드 위치체크

        //회전율
        var rotateRate = 0;
        //첫 비교 결과값을 담을 변수
        var firstResult = [];
        //비교 후 결과값을 담을 변수
        var calResult = [];

        //맨처음 색상분석을 위한 색상리스트
        var colorList = [
            [255, 233, 196],
            [254, 224, 174],
            [253, 215, 153],
            [244, 203, 149],
            [238, 219, 179],
            [238, 210, 160],
            [232, 191, 139],
            [223, 180, 112],
            [254, 236, 224],
            [255, 227, 213],
            [255, 222, 203],
            [250, 208, 184],
            [248, 230, 216],
            [249, 226, 208],
            [246, 216, 192],
            [236, 205, 177],
            //여기까지 톤색깔
            [220, 0, 18],//빨강
            [0, 152, 68],//초록
            [0, 159, 232],//하늘색
            [29, 32, 135],//파랑
            [95, 100, 255],//보라
            [223, 225, 217],//하양
            [0, 0, 0]//검정
        ]
        var warmColor = [
            //봄
            [255, 233, 196],
            [254, 224, 174],
            [253, 215, 153],
            [244, 203, 149],
            //가을
            [238, 219, 179],
            [238, 210, 160],
            [232, 191, 139],
            [223, 180, 112]

        ]
        var coolColor = [
            //여름
            [254, 236, 224],
            [255, 227, 213],
            [255, 222, 203],
            [250, 208, 184],
            //겨울
            [248, 230, 216],
            [249, 226, 208],
            [246, 216, 192],
            [236, 205, 177]
        ]
        var imgRed;
        var imgGreen;
        var imgBlue;

        //답변 갯수를 종합해줄 스택
        var answerStack = [];

        //크롭을 위한 좌표값
        var x;
        var y;
        var w;
        var h;
        let jcropApi = null;
        var resizeCheck;

        var slideCount = $('#slider ul li').length;
        var slideWidth = $('#slider ul li').width();
        var slideHeight = $('#slider ul li').height();
        var sliderUlWidth = slideCount * slideWidth;


        $('#slider ul').css({ width: sliderUlWidth, marginLeft: - slideWidth });

        $('#slider ul li:last-child').prependTo('#slider ul');

        //리사이징이벤트
        window.addEventListener("resize", function () {
            if (window.innerWidth < 768 && resizeCheck != "mob") {
                resizeCheck = "mob";
                if (jcropApi) {
                    jcropApi.destroy();
                    jcropApi = null;
                    resize();
                }
            }
            else if ((window.innerWidth < 1024 && window.innerWidth > 767) && resizeCheck != "tab") {
                resizeCheck = "tab";
                if (jcropApi) {
                    jcropApi.destroy();
                    jcropApi = null;
                    resize();
                }
            } else if (window.innerWidth > 1023 && resizeCheck != "pc") {
                resizeCheck = "pc";
                if (jcropApi) {
                    jcropApi.destroy();
                    jcropApi = null;
                    resize();
                }
            }

        });
        function div() {
            document.getElementsByClassName("jcrop-holder")[0].lastElementChild.id = "jcropImg";
            document.getElementsByClassName("jcrop-holder")[0].lastElementChild.style.opacity = 0.6;
            if (firstCrop == false) {

                document.getElementsByClassName("jcrop-holder")[0].className = "jcrop-holder aft";
                document.getElementsByClassName("jcrop-holder")[0].lastElementChild.style.opacity = 1;
            } else {
                firstCrop = false;
            }

        }

        //뒤로가기
        function moveLeft() {
            document.getElementById("mainbody").scrollIntoView();

            slideCheck--;
            if (slideCheck == 0) {
                document.getElementById("cropNotice").style.display = "block"
                document.getElementById("stepNum").innerHTML = "1";
                document.getElementById("subInfo").innerHTML = "피부\u00A0사진\u00A0촬영"
            }
            answerStack.pop();
            var slideWidth = $('#slider ul li').width();
            $('#slider ul').animate({

                left: + slideWidth
            }, 400, function () {
                $('#slider ul li:last-child').prependTo('#slider ul');
                $('#slider ul').css('left', '');
            });

        };
        //다음 단계로
        function moveRight(tone) {
            document.getElementById("mainbody").scrollIntoView();

            slideCheck++;
            if (slideCheck > 0) {
                document.getElementById("cropNotice").style.display = "none"
                document.getElementById("stepNum").innerHTML = "2";
                document.getElementById("subInfo").innerHTML = "질문\u00A05단계"
            }
            if (tone == "warm") {
                answerStack.push("warm");
            } else if (tone == "cool") {
                answerStack.push("cool");
            }
            if (slideCheck == 6) {
                var warm = 0;
                var cool = 0;
                for (var i = 0; i < answerStack.length; i++) {
                    if (answerStack[i] == "warm") {
                        warm++;
                    } else {
                        cool++;
                    }
                }
                if (warm < cool) {
                    season(coolColor, "cool");
                    return
                } else {
                    season(warmColor, "warm");
                    return
                }


            }

            var slideWidth = $('#slider ul li').width();
            $('#slider ul').animate({
                left: - slideWidth
            }, 400, function () {
                $('#slider ul li:first-child').appendTo('#slider ul');
                $('#slider ul').css('left', '');
            });

        };

        //이미지에서 색상추출
        function color(src) {
            document.getElementById("loading").style.display = "block"
            var colorThief = new ColorThief();

            var sourceImage = src
            try {

                colorThief.getColor(sourceImage)
            } catch (error) {
                document.getElementById("checkSuccess").style.display = "none"
                document.getElementById("checkFail").style.display = "block"
                document.getElementById("checkResult").style.display = "block"
                document.getElementById("loading").style.display = "none"
            }

            // Display palette of colors
            // e.g [[55,37,29],[213,193,136],[110,204,223]]
            imgRed = colorThief.getColor(sourceImage)[0];
            imgGreen = colorThief.getColor(sourceImage)[1];
            imgBlue = colorThief.getColor(sourceImage)[2];
            for (var i = 0; i < colorList.length; i++) {
                var color = "color" + i;
                var red = (imgRed - colorList[i][0]);
                red = red < 0 ? -(red) : red;
                var green = (imgGreen - colorList[i][1]);
                green = green < 0 ? -(green) : green;
                var blue = (imgBlue - colorList[i][2]);
                blue = blue < 0 ? -(blue) : blue;

                firstResult.push([red + green + blue, i]);
            }
            firstResult.sort(function (a, b) { // 오름차순 
                return a[0] - b[0];
            });
            var colorNum = firstResult[0][1];

            setTimeout(function () {

                document.getElementById("loading").style.display = "none"
                if (colorNum < 16) {
                    document.getElementById("checkSuccess").style.display = "block"
                    document.getElementById("checkFail").style.display = "none"

                    document.getElementById("checkResult").style.display = "block"

                    return;
                } else {
                    document.getElementById("checkSuccess").style.display = "none"
                    document.getElementById("checkFail").style.display = "block"
                    document.getElementById("checkResult").style.display = "block"
                }
            }, 1500);
            firstResult = [];

            // Display main color
            // e.g [125, 189, 193]
        }



        $('a.control_prev').click(function () {
            moveLeft();
        });

        $('a.control_next').click(function () {
            moveRight("aa");
        });



        //다음 버튼 눌렀을때 색상추출전이면 추출하고 아니면 다음단계로
        function next() {
            if (uploadCheck) {
                moveRight("");
            } else {
                color(document.getElementById("realImage"));
            }

        }
        function removeValue() {
            $("#fileInput").val("");
        }


        //자르기
        function crop() {
            try {


                if (cropCheck) {
                    return;
                }
                cropCheck = true;
                uploadCheck = false;
                document.getElementById("refreshBtn").disabled = false;
                //로드된 이미지를 캔버스에 출력
                //복사용 캔버스에 복사함. 하나의 캔버스에서 자기 자신을 불러와 크롭해서 리드로우가 불가능하기 때문.
                let canvas = document.getElementById("myCanvas");

                let canvasContext = canvas.getContext("2d");



                // @breif 캔버스 크기를 이미지 크기와 동일하게 지정

                var imgWidth = document.getElementById("copyCanvas").width;
                var imgHeight = document.getElementById("copyCanvas").height;
                //캔버스와 비율을 맞추기 위해 메인 이미지의 크기로 나눈다. jcrop이 원본이미지 크기를 줄이기때문에, jcrop의 자식의 크기를 가져온다
                var xRate = imgWidth / document.getElementById("jcropImg").width;
                var yRate = imgHeight / document.getElementById("jcropImg").height;
                canvas.width = w * xRate;

                canvas.height = h * yRate;
                if (canvas.width == 0 || canvas.height == 0) {
                    alert("더 이상 확대할 수 없습니다.")
                    cropCheck = false;
                    return;
                }
                canvasContext.drawImage(

                    document.getElementById("copyCanvas")

                    , x * xRate        // 자르기를 시작할 x좌표

                    , y * yRate       // 자르기를 시작할 y좌표

                    , w * xRate   // 잘라낸 이미지의 넓이

                    , h * yRate    // 잘라낸 이미지의 높이

                    , 0                                         // 캔버스에 이미지를 배치할 x좌표

                    , 0                                         // 캔버스에 이미지를 배치할 y좌표

                    , w * xRate  // 사용할 이미지의 넓이(이미지 스트레칭 또는 축소)

                    , h * yRate  // 사용할 이미지의 높이(이미지 스트레칭 또는 축소)

                );

                // console.log(canvas.getContext('2d').getImageData(50,50, 1, 1).data);
                // getImageData로 특정 좌표의 컬러 값을 가져올 수 있다.

                // 로드된 이미지를 캔버스에 출력
                let canvas2 = document.getElementById("copyCanvas");

                let canvasContext2 = canvas2.getContext("2d");



                // @breif 캔버스 크기를 이미지 크기와 동일하게 지정

                canvas2.width = document.getElementById("myCanvas").width;

                canvas2.height = document.getElementById("myCanvas").height;

                canvasContext2.drawImage(

                    document.getElementById("myCanvas"), 0, 0


                );



                if (jcropApi) {
                    jcropApi.destroy();
                    jcropApi = null;
                }
                // let canvas2 = document.getElementById("copyCanvas");

                // let canvasContext2 = canvas2.getContext("2d");
                // var image = new Image();
                // image.src = document.getElementById("realImage").src;
                // image.onload = function () {

                //     canvasContext2.drawImage(image, 0, 0, 200, 200);
                // }
                $(".file-upload-image").attr("src", getBase64Image());

                document.getElementById("realImage").style.transform = "none";
                rotateRate = 0;
                $("#realImage").Jcrop({
                    onSelect: showCoords,
                }, function () {
                    jcropApi = this;
                    div();
                });




                // @details JCROP을 종료한다.

            } catch (error) {
            }


        };
        //이미지 경로 설정


        // function readURL(input) {
        //     if (input.files && input.files[0]) {

        //         if (jcropApi) {
        //             jcropApi.destroy();

        //             jcropApi = null;
        //         }
        //         var files = input.files;
        //         var fileType = files[0].type;
        //         loadImage(files[0], function (img, data) {
        //             img.toBlob(function (blob) {
        //                 var rotateFile = new File([blob], files[0].name, {
        //                     type: fileType
        //                 });
        //                 sel_file = rotateFile;
        //                 var reader = new FileReader();
        //                 reader.onload = function (e) {
        //                     $('.image-upload-wrap').hide();
        //                     $('.file-upload-image').removeAttr("style");
        //                     $('.file-upload-image').attr('src', e.target.result);
        //                     $('.file-upload-image').css("display", "none");
        //                     $('#realImage').attr('src', document.getElementById("ToneImage").getAttribute("src"));
        //                     $('.file-upload-content').show();

        //                     $('.image-title').html(input.files[0].name);
        //                     $("#realImage").Jcrop({
        //                         onSelect: showCoords
        //                     }, function () {
        //                         jcropApi = this;
        //                     });
        //                 }
        //                 reader.readAsDataURL(rotateFile);
        //             }, fileType)
        //         }, {
        //             orientation: true
        //         });//end loadImage



        //     } else {
        //         removeUpload();
        //     }
        // }  블롭을 통해 자동으로 로테이트하는 함수, 그러나 지원하지 않는 브라우저가 많아서 포기.


        //브라우저 리사이징시 크롭 새롭게 불러와서 크기 맞게 적용.
        function resize() {
            $("#realImage").Jcrop({
                onSelect: showCoords,
            }, function () {
                jcropApi = this;
                div2();
            });
            function div2() {
                document.getElementsByClassName("jcrop-holder")[0].lastElementChild.id = "jcropImg";
                document.getElementsByClassName("file-upload-image")[1].style.transform = "rotate( " + rotateRate + "deg )";
                document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "rotate( " + rotateRate + "deg )";
                if (firstCrop == false) {

                    document.getElementsByClassName("jcrop-holder")[0].className = "jcrop-holder aft";
                    document.getElementsByClassName("jcrop-holder")[0].lastElementChild.style.opacity = 1;
                } else {
                    firstCrop = false;
                }
            }
        }
        //업로드된 이미지를 jcrop라이브러리로 변환하고 이미지를 캔버스에 그려놓는다.
        function editImg(callback, plusMinus) {
            editCheck = true;
            if (plusMinus) {

            } else {
                document.getElementById('editBtn').style.pointerEvents = 'none';
                if (rotateCrop) {
                    document.getElementsByClassName("jcrop-holder aft")[0].className = "jcrop-holder";
                    document.getElementsByClassName("jcrop-holder")[0].lastElementChild.id = "jcropImg";
                    document.getElementsByClassName("jcrop-holder")[0].lastElementChild.style.opacity = 0.6;
                    rotateCrop = false;
                    return;
                }
            }
            document.getElementById("editBtn").style.animation = "fade 0.5s"
            setTimeout(function () {
                document.getElementById("editBtn").style.animation = "unset"
            }, 500);
            let canvas = document.getElementById("copyCanvas");

            let canvasContext = canvas.getContext("2d");

            // @breif 캔버스의 이미지

            var image = new Image();
            image.src = document.getElementById("originalImg").src;
            image.onload = function () {

                canvas.width = this.width;

                canvas.height = this.height;
                $("#realImage").Jcrop({
                    onSelect: showCoords,
                }, function () {
                    jcropApi = this;
                    div();
                });


                //안드로이드인 내 폰에서는 방향에 맞게 자동으로 회전되어 등록되지만 애플은 그렇지 않다. 애플은 정방향에서 90도회전된 정보가 사진에 들어가 있다.
                //예를 들면 정방향에서 찍었으면 회전값이 1이어야 하는데 애플은 8이 나온다. 그래서 애플 디바이스를 위한 회전 로직을 따로 짜야했다.
                //그리고 데스크탑 같은 경우, 크롬은 자동으로 정방향으로 나오지만 엣지는 회전되어 나온다. 기기 별 대응이 너무 많아지기 떄문에, 자체적으로 회전 로직을 추가했다.
                //크롭을 하기위해선 캔버스가 필요한데, 애플 기기에서 업로드시 img태그에는 정방향으로 나오지만 캔버스에는 회전이 적용되어 나오기 때문에, 피부를 특정해서 crop해야 하는
                //이 앱에서는 자동회전이 불가피하게 되어 넣게 됐다.iPhone|iPad|iPod|Mac

                //망할놈의 캔버스. 아이폰6+페북, 아이패드+페북 에서는 정확히 잘됨. 그러나 아이폰xs+페북에서는 안드로이드처럼 정방향으로 잘나온다...
                //아이폰 xs에서만 이렇게 되면 예외처리를 해두면 되겠지만, 분명 다른 버전에서도 문제가 일어날 것이 뻔하다.. 대체 왜이러는걸까.
                //아이폰xs ios업데이트를 했더니 알아서 정방향으로 잘나온다. 이전에 했던 로직이 안먹힘. 하... 일단 ios 13.4버전 기준으로 자동회전을 시켜놨다.
                //아이패드에서도 실험해봤는데 13.5버전 또한 안드로이드처럼 정방향으로 잘나온다. 확실히 ios문제인거 같다. 정확히 이 패치가 몇 버전에서 이루어졌는지 알아내야한다.
                if (appleCheck) {
                    if (floatOs >= 13.4 || ua.indexOf("13.4") > -1 || ua.indexOf("13.5") > -1) {
                        canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                        if (plusMinus) callback(plusMinus);
                        return
                    }
                    // console.log("애플기기입니다.");
                    var fileInfo = document.getElementById("fileInput").files[0];
                    EXIF.getData(fileInfo, function () {
                        const orientation = EXIF.getTag(fileInfo, "Orientation");
                        // console.log("회전도는 " + orientation);
                        switch (orientation) {

                            // @details 이미지 회전값이 0인경우 ( 정방향 )
                            case undefined:
                                canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                                if (plusMinus) callback(plusMinus);
                                break;
                            case 1:


                                canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                                if (plusMinus) callback(plusMinus);
                                break;

                            case 3:


                                canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                canvasContext.rotate(Math.PI);
                                canvasContext.translate(-canvas.width / 2, -canvas.height / 2);



                                // @details 이미지가 180° 회전 했을 경우 x, y축의 값을 업로드 이미지의 넓이와 높이를 음수로 변경한다.

                                canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                                if (plusMinus) callback(plusMinus);
                                break;

                            // @details 이미지 회전값이 270 기운 경우 ( 왼쪽으로 90 기운 경우 )
                            case 6:
                                if (canvas.width < canvas.height) {
                                    canvas.width = canvas.height;
                                } else {
                                    canvas.height = canvas.width;
                                }

                                canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                canvasContext.rotate(Math.PI * 0.5);
                                canvasContext.translate(-canvas.width / 2, -canvas.height / 2);
                                canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                                if (plusMinus) callback(plusMinus);


                                // @details 이미지가 270° 회전 했을 경우 x축의 값을 업로드 이미지의 넓이를 음수로 변경한다.


                                break;

                            // @details 이미지 회전값이 90 기운 경우
                            case 8:
                                if (canvas.width < canvas.height) {
                                    canvas.width = canvas.height;
                                } else {
                                    canvas.height = canvas.width;
                                }

                                canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                canvasContext.rotate(Math.PI * 1.5);
                                canvasContext.translate(-canvas.width / 2, -canvas.height / 2);
                                canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                                if (plusMinus) callback(plusMinus);
                                //회전하기전에 정사각형을 만들어주자.
                                break;
                        }

                    })
                } else {
                    canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    if (plusMinus) callback(plusMinus);
                }


                // 사진편집을 누르면 편집 테두리가 전체를 감싸도록 설정
                $('.file-upload-content').show();
                // firstCrop = true;
            }

        }

        function cameraCheck() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {

                //사파리는 해상도가 자동으로 조절되기때문에 해상도를 설정해주면 에러가난다. 그래서 사파리는 설정을 안해줘야하는데,
                //기기 정보를 받아올때 크롬에는 사파리 크롬이 다 적혀있고, 사파리에는 사파리만 적혀있으므로 사파리를 특정하기 위해서는 
                //사파리 문자를 포함하고 크롬 문자를 포함하지않는 조건을 충족시켜줘야한다
                if (navigator.userAgent.indexOf('Safari') != -1 && navigator.userAgent.indexOf('Chrome') == -1) {
                    navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: { exact: "environment" }
                        }
                    }).then(function (stream) {
                        //video.src = window.URL.createObjectURL(stream);
                        document.getElementById("mainCam").style.display = "block"
                        document.getElementById("cropNotice").innerHTML = "※ 피부가 잘보이는 상태에서 측정 버튼을 눌러주세요"
                        modeChange()
                        video.srcObject = stream;
                        video.play();
                    }).catch(function (err) {
                        //err은 문자열이 아니기 때문에 문자열로 만들어줘야 indexOf가 가능
                        err = err + "";
                        if (err.indexOf("NotAllowedError") > -1) {
                            window.location.reload();
                        }
                        camErr()
                    });
                } else {
                    // Not adding `{ audio: true }` since we only want video now
                    navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { min: 1024, ideal: 1280, max: 1920 },
                            height: { min: 776, ideal: 720, max: 1080 }, facingMode: { exact: "environment" }
                        }
                    }).then(function (stream) {
                        //video.src = window.URL.createObjectURL(stream);
                        document.getElementById("mainCam").style.display = "block"
                        document.getElementById("cropNotice").innerHTML = "※ 팔목 피부가 잘 보일 때 측정 버튼을 눌러주세요"
                        modeChange()
                        video.srcObject = stream;
                        video.play();
                    }).catch(function (err) {
                        camErr()
                    });
                }
            }
            else if (navigator.getUserMedia) { // Standard
                navigator.getUserMedia({
                    video: {
                        width: { min: 1024, ideal: 1280, max: 1920 },
                        height: { min: 776, ideal: 720, max: 1080 }, facingMode: { exact: "user" }
                    }
                }, function (stream) {
                    document.getElementById("mainCam").style.display = "block"
                    document.getElementById("cropNotice").innerHTML = "※ 팔목 피부가 잘 보일 때 측정 버튼을 눌러주세요"
                    modeChange()
                    video.src = stream;
                    video.play();
                }, camErr());
            } else if (navigator.webkitGetUserMedia) { // WebKit-prefixed
                navigator.webkitGetUserMedia({
                    video: {
                        width: { min: 1024, ideal: 1280, max: 1920 },
                        height: { min: 776, ideal: 720, max: 1080 }, facingMode: { exact: "user" }
                    }
                }, function (stream) {
                    document.getElementById("mainCam").style.display = "block"
                    document.getElementById("cropNotice").innerHTML = "※ 팔목 피부가 잘 보일 때 측정 버튼을 눌러주세요"
                    modeChange()
                    video.src = window.webkitURL.createObjectURL(stream);
                    video.play();
                }, camErr());
            } else if (navigator.mozGetUserMedia) { // Mozilla-prefixed
                navigator.mozGetUserMedia({
                    video: {
                        width: { min: 1024, ideal: 1280, max: 1920 },
                        height: { min: 776, ideal: 720, max: 1080 }, facingMode: { exact: "environment" }
                    }
                }, function (stream) {
                    document.getElementById("mainCam").style.display = "block"
                    document.getElementById("cropNotice").innerHTML = "※ 팔목 피부가 잘 보일 때 측정 버튼을 눌러주세요"
                    modeChange()
                    video.srcObject = stream;
                    video.play();
                }, camErr());
            } else {
                camErr();
            }
        }
        function modeChange() {
            document.getElementById("mainbody").scrollIntoView();
            // if (navigator.userAgent.indexOf("Android") > 0 ||
            //     navigator.userAgent.indexOf("iPhone") > 0 ||
            //     navigator.userAgent.indexOf("iPod") > 0 ||
            //     navigator.userAgent.indexOf("iPad") > 0 ||
            //     navigator.userAgent.indexOf("BlackBerry") > 0) {
            //     document.getElementById("stepNum").style.paddingRight = "2.3vh";
            //     document.getElementById("stepNum").style.paddingTop = ".6vh";
            // }
            document.getElementById("subTitle").style.display = "none";
            document.getElementById("mainTitle").style.display = "none";
            document.getElementById("notice").style.display = "none";
            document.getElementById("stepInfo").style.display = "block";
            document.getElementById("cropNotice").style.display = "block";
            document.getElementById('editBtn').style.pointerEvents = 'auto';
            $('.image-upload-wrap').hide();
            $('.file-upload-image').removeAttr("style");
            $('#slider').show();
        }
        //인풋창 파일 업로드 시 
        function readURL(input) {

            if ((input.files && input.files[0])) {
                document.getElementById("loading").style.display = "block"

                // $('#originalImg').attr('src', tempImage.src);


                // $('.file-upload-image').css("display", "none");
                // $('#realImage').attr('src', e.target.result);
                uploadCheck = false;

                editCheck = false;
                if (jcropApi) {
                    jcropApi.destroy();

                    jcropApi = null;
                }
                firstCrop = true;
                const fileInfo = input.files[0];
                var reader = new FileReader();
                let tempImage = new Image();
                reader.onload = function (e) {
                    tempImage.src = e.target.result;
                    tempImage.onload = function () {

                        document.getElementById("originalImg").src = tempImage.src;
                        $('.file-upload-image').attr('src', tempImage.src);
                        modeChange();
                        // @breif 캔버스 위에 이미지 그리기


                    };


                    //회전값이 있는 사진을 정방향으로 돌리는 로직을 짜려했지만, 디바이스마다 회전값을 처리하는 기준이 달라서(특히 애플) 결국 포기하고 
                    //있는 그대로의 사진을 올리고 유저가 회전시킬 수 있게 바꾸었다...


                    // canvasContext.drawImage(tempImage, 0, 0, canvas.width, canvas.height);

                    //     await EXIF.getData(fileInfo, async () => {
                    //         // if (navigator.userAgent.indexOf('Mobile') != -1) {
                    //         //     canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    //         //     // console.log("모바일기기입니다.")
                    //         //     return
                    //         // }
                    //         fileInfo.exifdata = null;
                    //         console.log(EXIF.getAllTags(fileInfo));
                    //         const orientation = EXIF.getTag(fileInfo, "Orientation");
                    //         console.log("회전도는 "+orientation);

                    //         switch (orientation) {

                    //             // @details 이미지 회전값이 0인경우 ( 정방향 )
                    //             case undefined:

                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    //                 $('.image-upload-wrap').hide();
                    // $('.file-upload-image').removeAttr("style");
                    // $('.file-upload-image').attr('src', getBase64Image());

                    //  $('#originalImg').attr('src', getBase64Image());
                    //   $("#realImage").Jcrop({
                    //     onSelect: showCoords,
                    // }, function () {
                    //     jcropApi = this;
                    // });

                    // // $('.file-upload-image').css("display", "none");
                    // // $('#realImage').attr('src', e.target.result);
                    // $('.file-upload-content').show();
                    // $('.image-title').html(input.files[0].name);
                    //             //    callback(canvas);

                    //                 break;
                    //             case 1:

                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    //                 break;
                    //             case 0:

                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    //                 break;
                    //             // @details 이미지 회전값이 180 기운 경우
                    //             case 3:
                    //                 // document.getElementById("realImage").style.transform = "rotate( 180deg )";
                    //                 // document.getElementById("originalImg").style.transform = "rotate( 180deg )";
                    //                 // document.getElementsByClassName("file-upload-image")[1].style.transform = "rotate( 180deg )";
                    //                 // document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "rotate(180deg)";





                    //                 // canvasContext.rotate((180) * Math.PI / 180);

                    //                 canvasContext.translate(canvas.width / 2, canvas.height / 2);
                    //                 canvasContext.rotate(Math.PI);
                    //                 canvasContext.translate(-canvas.width / 2, -canvas.height / 2);




                    //                 // @details 이미지가 180° 회전 했을 경우 x, y축의 값을 업로드 이미지의 넓이와 높이를 음수로 변경한다.

                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);

                    //                 break;

                    //             // @details 이미지 회전값이 270 기운 경우 ( 왼쪽으로 90 기운 경우 )
                    //             case 6:
                    //                 if (canvas.width < canvas.height) {
                    //                     canvas.width = canvas.height;
                    //                 } else {
                    //                     canvas.height = canvas.width;
                    //                 }
                    //                 // document.getElementById("realImage").style.transform = "rotate( 90deg )";
                    //                 // document.getElementById("originalImg").style.transform = "rotate( 90deg )";
                    //                 // document.getElementsByClassName("file-upload-image")[1].style.transform = "rotate( 90deg )";
                    //                 // document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "rotate(90deg)";
                    //                 // @details 270° 회전의 경우 이미지의 높이와 넓이를 서로 바꿔준다.


                    //                 // tempImage.src = document.getElementById("ToneImage").getAttribute("src");
                    //                 // canvasContext.save();
                    //                 // canvasContext.translate(tempImage.width / 2, tempImage.height / 2);
                    //                 // canvasContext.rotate(Math.PI * 0.5);

                    //                 // canvasContext.drawImage(this, -1490,-0);

                    //                 // canvasContext.restore();
                    //                 console.log("ㅅㅂ");
                    //                 canvasContext.translate(canvas.width / 2, canvas.height / 2);
                    //                 canvasContext.rotate(Math.PI * 0.5);
                    //                 canvasContext.translate(-canvas.width / 2, -canvas.height / 2);
                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);



                    //                 // @details 이미지가 270° 회전 했을 경우 x축의 값을 업로드 이미지의 넓이를 음수로 변경한다.


                    //                 break;

                    //             // @details 이미지 회전값이 90 기운 경우
                    //             case 8:
                    //                 //회전하기전에 정사각형을 만들어주자.
                    //                 if (canvas.width < canvas.height) {
                    //                     canvas.width = canvas.height;
                    //                 } else {
                    //                     canvas.height = canvas.width;
                    //                 }
                    //                 // document.getElementById("realImage").style.transform = "rotate( 270deg )";
                    //                 // document.getElementById("originalImg").style.transform = "rotate( 270deg )";
                    //                 // document.getElementsByClassName("file-upload-image")[1].style.transform = "rotate( 270deg )";
                    //                 // document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "rotate(270deg)";
                    //                 // @details 90° 회전의 경우 이미지의 높이와 넓이를 서로 바꿔준다.




                    //                 // canvasContext.rotate((90) * Math.PI / 180);

                    //                 //캔버스의 중심점 설정.
                    //                 canvasContext.translate(canvas.width / 2, canvas.height / 2);
                    //                 canvasContext.rotate(Math.PI * 1.5);
                    //                 //회전시킨 후 다시 중심점 0,0으로 설정.
                    //                 canvasContext.translate(-canvas.width / 2, -canvas.height / 2);


                    //                 // @details 이미지가 90° 회전 했을 경우 y축의 값을 업로드 이미지의 높이를 음수로 변경한다.
                    //                 canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                    //                 break;
                    //         }
                    //     });
                    // let dataURI = canvas.toDataURL("image/jpeg");

                    // document.querySelector("#ToneImage").src = dataURI;



                }

                reader.readAsDataURL(fileInfo);
                document.getElementById("loading").style.display = "none"

            } else {
                removeUpload();
            }
        }


        //이미지 회전.
        function rotateImg(plusMinus) {
            document.getElementById("rotateBtn").style.animation = "fade 0.5s"
            setTimeout(function () {
                document.getElementById("rotateBtn").style.animation = "unset"
            }, 500);
            if (plusMinus == "right") {
                rotateRate += 90;
            } else {
                rotateRate -= 90;
            }

            if (rotateRate == 360 || rotateRate == -360) {
                rotateRate = 0;
            }

            if (!editCheck) {
                firstCrop = false;
                rotateCrop = true;
                //캔버스에 그림이 그려진 후 회전을 시켜야해서 콜백함수로 순서를 맞춤.
                editImg(rotateCall, plusMinus);

            } else {
                rotateCall(plusMinus);
            }

        }
        function rotateCall(plusMinus) {
            let canvas = document.getElementById("copyCanvas");

            let canvasContext = canvas.getContext("2d");

            let rotateCanvas = document.getElementById("myCanvas");
            let rtx = rotateCanvas.getContext("2d");
            document.getElementById("realImage").style.transform = "rotate( " + rotateRate + "deg )";
            document.getElementById("originalImg").style.transform = "rotate( " + rotateRate + "deg )";
            if (document.getElementsByClassName("jcrop-holder")[0]) {
                document.getElementsByClassName("file-upload-image")[1].style.transform = "rotate( " + rotateRate + "deg )";
                document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "rotate( " + rotateRate + "deg )";

            }
            rotateCanvas.width = canvas.width;
            rotateCanvas.height = canvas.height;

            if (rotateCanvas.width < rotateCanvas.height) {
                rotateCanvas.width = rotateCanvas.height;
            } else {
                rotateCanvas.height = rotateCanvas.width;
            }

            // 캔버스의 중심점 설정.
            rtx.translate(rotateCanvas.width / 2, rotateCanvas.height / 2);
            if (plusMinus == "right") {
                rtx.rotate(Math.PI * 0.5);
            } else {
                rtx.rotate(Math.PI * -0.5);

            }
            rtx.translate(-rotateCanvas.width / 2, -rotateCanvas.height / 2);
            rtx.drawImage(canvas, 0, 0, rotateCanvas.width, rotateCanvas.height);



            //회전용 캔버스의 내용을 다시 메인 캔버스에 복사해준다. 이미지를 회전시켜 캔버스에 그리면 편하나, 원래 이미지를 회전시킨건 단순 css를 통한 회전이다
            //캔버스에는 회전이 적용되지않은 원래의 이미지가 그려지기 때문에 메인캔버스의 그림을 불러와 서브캔버스에 회전한 상태를 그린 후, 다시 서브에서 메인으로 옮겨 그린다.
            canvas.width = rotateCanvas.width;
            canvas.height = rotateCanvas.height;

            canvasContext.drawImage(rotateCanvas, 0, 0, rotateCanvas.width, rotateCanvas.height);
        }
        function removeUpload() {
            $('.file-upload-input').replaceWith($('.file-upload-input').clone());
            $('.file-upload-content').hide();
            $('.image-upload-wrap').show();
        }
        $('.image-upload-wrap').bind('dragover', function () {
            $('.image-upload-wrap').addClass('image-dropping');
        });
        $('.image-upload-wrap').bind('dragleave', function () {
            $('.image-upload-wrap').removeClass('image-dropping');
        });



        //크롭 영역 지정 이벤트 함수
        var showCoords = function (c) {
            cropCheck = false;
            if (document.getElementsByClassName("jcrop-holder")[0]) {
                document.getElementsByClassName("jcrop-holder")[0].className = "jcrop-holder aft";
            }

            x = c.x;
            y = c.y;
            w = c.w;
            h = c.h;
        };

        //캔버스의 이미지를 base64로 변환
        function getBase64Image() {

            var canvas = document.getElementById("copyCanvas");

            var dataURL = canvas.toDataURL("image/png");

            return dataURL; // dataURL.replace(/^data:image\/(png|jpg);base64,/, "");

        }


        //사진 원상복구. 숨겨놓앗던 오리지널 이미지태그를 불러와 캔버스에 다시그림
        function refresh() {
            document.getElementById("refreshBtn").style.animation = "fade 0.5s"
            setTimeout(function () {
                document.getElementById("refreshBtn").style.animation = "unset"
            }, 500);
            uploadCheck = false;
            cropCheck = true;
            rotateRate = 0;
            document.getElementById("refreshBtn").disabled = true;
            document.getElementById("originalImg").style.transform = "none";
            var image = new Image();
            image.src = document.getElementById("originalImg").src;
            document.getElementById("realImage").src = image.src;
            document.getElementsByClassName("file-upload-image")[1].src = image.src;
            document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.src = image.src;
            document.getElementsByClassName("file-upload-image")[1].style.transform = "none";
            document.getElementsByClassName("jcrop-holder")[0].firstElementChild.firstElementChild.firstElementChild.style.transform = "none";

            var canvas = document.getElementById("copyCanvas");
            var canvasContext = canvas.getContext("2d");



            // canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);
            try {


                image.onload = function () {
                    canvas.width = this.width;
                    canvas.height = this.height;
                    if (appleCheck) {
                        if (floatOs >= 13.4 || ua.indexOf("13.4") > -1 || ua.indexOf("13.5") > -1) {
                            canvasContext.drawImage(this, 0, 0, canvas.width, canvas.height);
                            if (plusMinus) callback(plusMinus);
                            return
                        }
                        var fileInfo = document.getElementById("fileInput").files[0];
                        EXIF.getData(fileInfo, function () {
                            const orientation = EXIF.getTag(fileInfo, "Orientation");
                            // console.log("회전도는 " + orientation);
                            switch (orientation) {

                                // @details 이미지 회전값이 0인경우 ( 정방향 )

                                case 1:


                                    canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);
                                    break;
                                case undefined:


                                    canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);
                                    break;

                                case 3:


                                    canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                    canvasContext.rotate(Math.PI);
                                    canvasContext.translate(-canvas.width / 2, -canvas.height / 2);



                                    // @details 이미지가 180° 회전 했을 경우 x, y축의 값을 업로드 이미지의 넓이와 높이를 음수로 변경한다.

                                    canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);

                                    break;

                                // @details 이미지 회전값이 270 기운 경우 ( 왼쪽으로 90 기운 경우 )
                                case 6:
                                    if (canvas.width < canvas.height) {
                                        canvas.width = canvas.height;
                                    } else {
                                        canvas.height = canvas.width;
                                    }

                                    canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                    canvasContext.rotate(Math.PI * 0.5);
                                    canvasContext.translate(-canvas.width / 2, -canvas.height / 2);
                                    canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);



                                    // @details 이미지가 270° 회전 했을 경우 x축의 값을 업로드 이미지의 넓이를 음수로 변경한다.


                                    break;

                                // @details 이미지 회전값이 90 기운 경우
                                case 8:
                                    if (canvas.width < canvas.height) {
                                        canvas.width = canvas.height;
                                    } else {
                                        canvas.height = canvas.width;
                                    }

                                    canvasContext.translate(canvas.width / 2, canvas.height / 2);
                                    canvasContext.rotate(Math.PI * 1.5);
                                    canvasContext.translate(-canvas.width / 2, -canvas.height / 2);
                                    canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);

                                    //회전하기전에 정사각형을 만들어주자.x
                                    break;
                            }


                        })
                    } else {
                        canvasContext.drawImage(image, 0, 0, canvas.width, canvas.height);



                    }
                }
            } catch (error) {
                console.log(error);
            }
        }


        //색상과 질문 총 결과값을 종합하여 결과 도출
        function season(colorGroup, toneColor) {
            document.getElementById("loading").style.display = "block"
            var length = colorGroup.length
            for (var i = 0; i < length; i++) {
                var red = (imgRed - colorGroup[i][0]);
                red = red < 0 ? -(red) : red;
                var green = (imgGreen - colorGroup[i][1]);
                green = green < 0 ? -(green) : green;
                var blue = (imgBlue - colorGroup[i][2]);
                blue = blue < 0 ? -(blue) : blue;

                calResult.push([red + green + blue, i]);

            }
            var length2 = calResult.length
            var season1 = [];
            var season2 = [];
            calResult.sort(function (a, b) { // 오름차순 
                return a[0] - b[0];
            });
            for (var i = 0; i < length2; i++) {
                if (calResult[i][1] <= 3) {
                    season1.push(calResult[i][0])
                    season1.push(calResult[i][1])
                } else {
                    season2.push(calResult[i][0])
                    season2.push(calResult[i][1])
                }
                if (season2[0] && season1[0]) {
                    break;
                }
            }
            // if (toneColor == "warm") {
            //     season1 -= season1 / 5
            // } else {

            //     season1 -= season1 / 7.3
            // }
            if (season2[0] < 200 || season1[0] < 200) {
                if (toneColor == "warm") {
                    season1[0] -= season2[0] * 0.3
                } else {
                    season1[0] -= season2[0] * 0.26
                }
            }
            var colorNum = season1[0] == season2[0] ? calResult[0][1] : season1[0] < season2[0] ? season1[1] : season2[1];
            setTimeout(function () {
                if (0 <= colorNum && colorNum <= 3 && toneColor == "warm") {
                    window.location.href = "https://mycolor.kr/springWarm"
                } else if (toneColor == "warm") {
                    window.location.href = "https://mycolor.kr/fallWarm"
                } else if (0 <= colorNum && colorNum <= 3 && toneColor == "cool") {
                    window.location.href = "https://mycolor.kr/summerCool"
                } else {
                    window.location.href = "https://mycolor.kr/winterCool"
                }
            }, 1500);

            calResult = [];
        }



    </script>
    <script>



        (function () { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://personalcolor.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>

</body>

</html>
<!-- Copyright (c) 2020 by zuraiz (https://codepen.io/zuraizm/pen/vGDHl)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

The MIT License

Copyright 짤2008 Kelly Hallman and Deep Liquid Group
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"),
 to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.


THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 Copyright (c) 2020 by Aaron Vanston (https://codepen.io/aaronvanston/pen/yNYOXR)

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


 -->